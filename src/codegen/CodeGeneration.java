package codegen;

import scanner.TokenType;
import symboltable.SymbolTable;
import syntaxtree.*;

/**
 * @author William Mork
 *
 * This class will uses the syntax tree generated by the parser to create MIPS assembly code.
 */
public class CodeGeneration {

    private ProgramNode programNode;
    private SymbolTable symbolTable;
    private int currentReg;
    private int loopIndex;
    private int ifIndex;

    public CodeGeneration(ProgramNode inputProgramNode, SymbolTable inputSymbolTable){
        programNode = inputProgramNode;
        symbolTable = inputSymbolTable;
        currentReg = 0;
        loopIndex = 0;
        ifIndex = 0;
    }

    public String codeWriter(){
        StringBuilder codeString = new StringBuilder();

        codeString.append(".data\n");
        for(VariableNode variable: programNode.getDeclarations().getVariables()){
            codeString.append(variable.getName()).append("\t:.word\t0\n");
            symbolTable.getSymbol(variable.getName()).setAddress(variable.getName());
        }
        codeString.append(".text\n");
        codeString.append("main:\n");
        codeString.append(pushToStack());

        for (StatementNode statement : programNode.getCompoundStatement().getStatements()) {
            codeString.append(statementWriter(statement, "$s" + currentReg));
        }

        codeString.append(popFromStack());

        return codeString.toString();
    }

    public String operationWriter(OperationNode operationNode, String resultReg) {
        StringBuilder operationString = new StringBuilder();

        ExpressionNode leftExpression = operationNode.getLeft();
        String leftReg = "$t" + currentReg++;
        operationString.append(expressionWriter(leftExpression, leftReg));
        ExpressionNode rightExpression = operationNode.getRight();
        String rightReg = "$t" + currentReg++;
        operationString.append(expressionWriter(rightExpression, rightReg));
        TokenType operationType = operationNode.getOperation();
        switch(operationType)
        {
            case PLUS:
                operationString.append("add    " + resultReg + ",   " + leftReg + ",   " + rightReg + "\n");
            case MINUS:
                operationString.append("sub    " + resultReg + ",   " + leftReg +",   " + rightReg + "\n");
            case MULTIPLY:
                operationString.append("mult   " + leftReg + ",   " + rightReg + "\n");
                operationString.append("mflo   " + resultReg + "\n");
            case AND:
                operationString.append("and\t").append(resultReg).append(",\t").append(leftReg).append(",\t").append(rightReg).append("\n");
            case OR:
                operationString.append("or\t").append(resultReg).append(",\t").append(leftReg).append(",\t").append(rightReg).append("\n");
            case LTHAN:
                operationString.append("bge\t").append(leftReg).append(",\t").append(rightReg).append(",\t");
            case GTHAN:
                operationString.append("ble\t").append(leftReg).append(",\t").append(rightReg).append(",\t");
            case LTHANEQ:
                operationString.append("bgt\t").append(leftReg).append(",\t").append(rightReg).append(",\t");
            case GTHANEQ:
                operationString.append("blt\t").append(leftReg).append(",\t").append(rightReg).append(",\t");
            case EQUAL:
                operationString.append("bne\t").append(leftReg).append(",\t").append(rightReg).append(",\t");
            case NOTEQ:
                operationString.append("beq\t").append(leftReg).append(",\t").append(rightReg).append(",\t");
        }

        this.currentReg -= 2;
        return operationString.toString();
    }

    /**
     * Generates assembly code for a value node.
     *
     * @param valueNode The value node
     * @param resultReg The MIPS register where the result is stored.
     * @return MIPS assembly code for a value store.
     */
    public String valueWriter(ValueNode valueNode, String resultReg)
    {
        StringBuilder valueString = new StringBuilder();

        String value = valueNode.getAttribute();
        valueString.append("addi   " + resultReg + ",   $zero, " + value + "\n");
        return valueString.toString();
    }


    public String expressionWriter(ExpressionNode expressionNode, String resultReg) {
        StringBuilder expressionString = new StringBuilder();

        if(expressionNode instanceof ValueNode){
            expressionString.append(valueWriter((ValueNode) expressionNode, resultReg));
        }
        else if (expressionNode instanceof OperationNode){
            expressionString.append(operationWriter((OperationNode) expressionNode, resultReg));
        }
        else if (expressionNode instanceof VariableNode){
            if(symbolTable.getSymbol(((VariableNode) expressionNode).getName()) != null){
                String variable = symbolTable.getSymbol(((VariableNode) expressionNode).getName()).getAddress();
                expressionString.append("lw\t").append(resultReg).append(",\t").append(variable).append("\n");
            }
            else{
                expressionString.append("addi   " + resultReg + ",   $zero, " + ((VariableNode) expressionNode).getName()+ "\n");
            }
        } else {
            expressionString.append("[ERROR: Code for expression could not be generated.]");
        }
        return expressionString.toString();
    }

    public String statementWriter(StatementNode statementNode, String resultReg) {
        StringBuilder statementString = new StringBuilder();

        if (statementNode instanceof AssignmentStatementNode){
            statementString.append(assignmentWriter((AssignmentStatementNode) statementNode, resultReg));
        }
        else if (statementNode instanceof IfStatementNode){
            statementString.append(ifStatementWriter((IfStatementNode) statementNode, resultReg));
        }
        else if (statementNode instanceof WhileStatementNode){
            statementString.append(whileStatementWriter((WhileStatementNode) statementNode, resultReg));
        }
        else if (statementNode instanceof CompoundStatementNode){
            statementString.append(statementWriter((CompoundStatementNode) statementNode, resultReg));
        }else{
            statementString.append("[ERROR: Code for statement could not be generated.]");
        }

        return statementString.toString();
    }

    private String ifStatementWriter(IfStatementNode ifStatementNode, String resultReg) {
        StringBuilder ifStatementString = new StringBuilder();

        // Begin if statement.
        ifStatementString.append(operationWriter((OperationNode) ifStatementNode.getTest(), resultReg)).append("else").append(ifIndex).append("\n");
        // then.
        resultReg = "$s" + currentReg++;
        ifStatementString.append(statementWriter(ifStatementNode.getThenStatement(), resultReg));
        ifStatementString.append("\nj\tendIf").append(ifIndex).append("\n");
        // else.
        resultReg = "$s" + currentReg++;
        ifStatementString.append("else").append(ifIndex).append(":\n");
        ifStatementString.append(statementWriter(ifStatementNode.getElseStatement(), resultReg));
        ifStatementString.append("\nendIf").append(ifIndex).append(":\n");

        currentReg -= 2;
        return ifStatementString.toString();
    }

    private String whileStatementWriter(WhileStatementNode whileStatementNode, String resultReg) {
        StringBuilder whileStatementString = new StringBuilder();

        // Begin while statement.
        whileStatementString.append("while").append(loopIndex).append(":\n");
        whileStatementString.append(expressionWriter(whileStatementNode.getTest(), resultReg));
        whileStatementString.append("endWhile").append(loopIndex).append(":\n");
        currentReg++;

        resultReg = "$s" + currentReg;
        whileStatementString.append(statementWriter(whileStatementNode.getDoStatement(), resultReg));
        whileStatementString.append("\tj while").append(loopIndex).append(":\n");
        whileStatementString.append("endWhile").append(loopIndex).append(":\n");
        currentReg--;

        return whileStatementString.toString();
    }

    private String assignmentWriter(AssignmentStatementNode assignmentStatementNode, String resultReg) {
        StringBuilder assignmentString = new StringBuilder();
        // Begin Assignment.
        assignmentString.append(expressionWriter(assignmentStatementNode.getExpression(), resultReg));
        assignmentString.append("sw\t").append(resultReg).append(",\t").append(symbolTable.getSymbol(assignmentStatementNode.getLvalue().getName()).getAddress());
        return assignmentString.toString();
    }

    private String pushToStack() {
        StringBuilder pushString = new StringBuilder();
        // Push to stack.
        pushString.append("addi\t$sp,\t$sp,\t-");
        pushString.append(8 * 4 + 8);
        pushString.append('\n');

        for (int i = 8 - 1; i >= 0; i--) {
            pushString.append("sw\t").append("$s").append(i).append(",\t").append(4 * (i + 2)).append("($sp)\n");
        }

        pushString.append("sw\t$fp,\t4($sp)\n");
        pushString.append("sw\t$ra,\t0($sp)\n");

        return pushString.toString();
    }

    private String popFromStack() {
        StringBuilder popString = new StringBuilder();
        // Pop from stack.

        for (int i = 8 - 1; i >= 0; i--) {
            popString.append("lw\t").append("$s").append(i).append(",\t").append(4 * (i + 2)).append("($sp)\n");
        }
        popString.append("lw\t$fp,\t4($sp)\n");
        popString.append("lw\t$ra,\t0($sp)\n");
        popString.append("addi\t$sp,\t$sp,\t");
        popString.append((8 * 4) + 8).append("\n");
        popString.append("jr\t$ra\n");

        return popString.toString();
    }

}
