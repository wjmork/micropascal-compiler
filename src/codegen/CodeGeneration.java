package codegen;

import scanner.TokenType;
import symboltable.SymbolTable;
import syntaxtree.*;

/**
 * @author William Mork
 *
 * This class will uses the syntax tree generated by the parser to create MIPS assembly code.
 */
public class CodeGeneration {

    private ProgramNode programNode;
    private SymbolTable symbolTable;
    private int currentReg;
    private int loopIndex;
    private int ifIndex;

    /**
     * This class generates MIPS assembly code based on the syntax tree generated by the parser.
     *
     * @param inputProgramNode The root program node of the syntax tree.
     * @param inputSymbolTable The symbol table generated by the parser.
     * @author William Mork
     */
    public CodeGeneration(ProgramNode inputProgramNode, SymbolTable inputSymbolTable){
        programNode = inputProgramNode;
        symbolTable = inputSymbolTable;
        currentReg = 0;
        loopIndex = 0;
        ifIndex = 0;
    }

    /**
     * Top-level code generation method.
     * @return String of the MIPS assembly code of the syntax tree.
     */
    public String codeWriter(){
        StringBuilder codeString = new StringBuilder();

        // .data section
        codeString.append(".data\n");
        for(VariableNode variable: programNode.getDeclarations().getVariables()){
            codeString.append(variable.getName()).append(":\t.word\t0\n");
            symbolTable.getSymbol(variable.getName()).setAddress(variable.getName());
        }

        codeString.append("\n");

        // .text section
        codeString.append(".text\n");
        codeString.append("main:\n");

        // push to stack
        codeString.append(pushToStack());

        // generate program compound statement
        for (StatementNode statement : programNode.getCompoundStatement().getStatements()) {
            codeString.append(statementWriter(statement, "$s" + currentReg));
        }

        // pop from stack
        codeString.append(popFromStack());

        return codeString.toString();
    }

    /**
     * Code generation method for operation nodes.
     *
     * @param operationNode An operation node.
     * @param resultReg The MIPS register to store a result.
     * @return MIPS assembly for an operation node.
     */
    public String operationWriter(OperationNode operationNode, String resultReg) {
        StringBuilder operationString = new StringBuilder();

        ExpressionNode leftExpression = operationNode.getLeft();
        String leftReg = "$t" + currentReg++;
        operationString.append(expressionWriter(leftExpression, leftReg));
        ExpressionNode rightExpression = operationNode.getRight();
        String rightReg = "$t" + currentReg++;
        operationString.append(expressionWriter(rightExpression, rightReg));
        TokenType operationType = operationNode.getOperation();

        switch(operationType)
        {
            case PLUS:
                operationString.append("add\t" + resultReg + ",\t" + leftReg + ",\t" + rightReg + "\n");
                break;
            case MINUS:
                operationString.append("sub\t" + resultReg + ",\t" + leftReg +",\t" + rightReg + "\n");
                break;
            case MULTIPLY:
                operationString.append("mult\t" + leftReg + ",\t" + rightReg + "\n");
                operationString.append("mflo\t" + resultReg + "\n");
                break;
            case DIVIDE:
                operationString.append("div\t").append(leftReg).append(",\t").append(rightReg).append("\n");
                operationString.append("mflo\t").append(resultReg).append("\n");
                break;
            case AND:
                operationString.append("and\t").append(resultReg).append(",\t").append(leftReg).append(",\t").append(rightReg).append("\n");
                break;
            case OR:
                operationString.append("or\t").append(resultReg).append(",\t").append(leftReg).append(",\t").append(rightReg).append("\n");
                break;
            case LTHAN:
                operationString.append("bge\t").append(leftReg).append(",\t").append(rightReg).append(",\t");
                break;
            case GTHAN:
                operationString.append("ble\t").append(leftReg).append(",\t").append(rightReg).append(",\t");
                break;
            case LTHANEQ:
                operationString.append("bgt\t").append(leftReg).append(",\t").append(rightReg).append(",\t");
                break;
            case GTHANEQ:
                operationString.append("blt\t").append(leftReg).append(",\t").append(rightReg).append(",\t");
                break;
            case EQUAL:
                operationString.append("bne\t").append(leftReg).append(",\t").append(rightReg).append(",\t");
                break;
            case NOTEQ:
                operationString.append("beq\t").append(leftReg).append(",\t").append(rightReg).append(",\t");
                break;
        }

        this.currentReg -= 2;
        return operationString.toString();
    }

    /**
     * Code generation method for value nodes.
     *
     * @param valueNode A value node.
     * @param resultReg The MIPS register to store a result.
     * @return MIPS assembly for a value node.
     */
    public String valueWriter(ValueNode valueNode, String resultReg)
    {
        StringBuilder valueString = new StringBuilder();

        String value = valueNode.getAttribute();
        valueString.append("addi\t" + resultReg + ",\t$zero,\t" + value + "\n");
        return valueString.toString();
    }

    /**
     * Code generation method for an expression node.
     *
     * @param expressionNode An expression node.
     * @param resultReg The MIPS register to store a result.
     * @return MIPS assembly for an expression node.
     */
    public String expressionWriter(ExpressionNode expressionNode, String resultReg) {
        StringBuilder expressionString = new StringBuilder();

        if(expressionNode instanceof ValueNode){
            expressionString.append(valueWriter((ValueNode) expressionNode, resultReg));
        }
        else if (expressionNode instanceof OperationNode){
            expressionString.append(operationWriter((OperationNode) expressionNode, resultReg));
        }
        else if (expressionNode instanceof VariableNode) {
            if(symbolTable.getSymbol(((VariableNode) expressionNode).getName()) != null) {
                String var = symbolTable.getSymbol(((VariableNode) expressionNode).getName()).getAddress();
                expressionString.append("la\t").append(resultReg).append(",\t").append(var).append("\n");
            } else {
                expressionString.append("lw\t" + resultReg + ",\t" + ((VariableNode) expressionNode).getName()+ "\n");
            }
        }
        return expressionString.toString();
    }

    /**
     * Code generation method for a statement node.
     *
     * @param statementNode A statement node.
     * @param resultReg The MIPS register to store a result.
     * @return MIPS assembly for a statement node.
     */
    public String statementWriter(StatementNode statementNode, String resultReg) {
        StringBuilder statementString = new StringBuilder();

        if (statementNode instanceof AssignmentStatementNode){
            statementString.append(assignmentWriter((AssignmentStatementNode) statementNode, resultReg));
        }
        else if (statementNode instanceof IfStatementNode){
            statementString.append(ifStatementWriter((IfStatementNode) statementNode, resultReg));
        }
        else if (statementNode instanceof WhileStatementNode){
            statementString.append(whileStatementWriter((WhileStatementNode) statementNode, resultReg));
        }
        else if (statementNode instanceof CompoundStatementNode){
            for (StatementNode statement : ((CompoundStatementNode) statementNode).getStatements()) {
                statementString.append(statementWriter(statement, resultReg));
            }
        }else{
            statementString.append("[ERROR: Code for statement could not be generated.]");
        }

        return statementString.toString();
    }

    /**
     * Code generation method for an if statement node.
     *
     * @param ifStatementNode An if statement node.
     * @param resultReg The MIPS register to store a result.
     * @return MIPS assembly for an if statement node.
     */
    private String ifStatementWriter(IfStatementNode ifStatementNode, String resultReg) {
        StringBuilder ifStatementString = new StringBuilder();

        // Begin if statement.
        ifStatementString.append(operationWriter((OperationNode) ifStatementNode.getTest(), resultReg)).append("else").append(ifIndex).append("\n");

        // then.
        resultReg = "$s" + currentReg++;
        ifStatementString.append(statementWriter(ifStatementNode.getThenStatement(), resultReg));
        ifStatementString.append("j\tendIf").append(ifIndex).append("\n");

        // else.
        resultReg = "$s" + currentReg++;
        ifStatementString.append("else").append(ifIndex).append(":\n");
        ifStatementString.append(statementWriter(ifStatementNode.getElseStatement(), resultReg));
        ifStatementString.append("\nendIf").append(ifIndex).append(":\n");

        currentReg -= 2;
        return ifStatementString.toString();
    }

    /**
     * Code generation method for a while statement node.
     *
     * @param whileStatementNode A while statement node.
     * @param resultReg The MIPS register to store a result.
     * @return MIPS assembly for a while statement node.
     */
    private String whileStatementWriter(WhileStatementNode whileStatementNode, String resultReg) {
        StringBuilder whileStatementString = new StringBuilder();

        // Begin while statement.
        whileStatementString.append("while").append(loopIndex).append(":\n");
        whileStatementString.append(expressionWriter(whileStatementNode.getTest(), resultReg));
        whileStatementString.append("endWhile").append(loopIndex).append("\n");
        currentReg++;

        resultReg = "$s" + ++currentReg;
        whileStatementString.append(statementWriter(whileStatementNode.getDoStatement(), resultReg));
        whileStatementString.append("j\t while").append(loopIndex).append("\n");
        whileStatementString.append("endWhile").append(loopIndex).append(":\n");
        currentReg--;

        return whileStatementString.toString();
    }

    /**
     * Code generation method for an assignment statement node.
     *
     * @param assignmentStatementNode An assignment statement node.
     * @param resultReg The MIPS register to store a result.
     * @return MIPS assembly for an assignment statement node.
     */
    private String assignmentWriter(AssignmentStatementNode assignmentStatementNode, String resultReg) {
        StringBuilder assignmentString = new StringBuilder();

        // Begin assignment.
        assignmentString.append(expressionWriter(assignmentStatementNode.getExpression(), resultReg));
        assignmentString.append("sw\t").append(resultReg).append(",\t").append(symbolTable.getSymbol(assignmentStatementNode.getLvalue().getName()).getAddress());
        assignmentString.append("\n");
        return assignmentString.toString();
    }

    /**
     * Code generation method for pushing registers $s*, $fp, and $sp to the stack.
     *
     * @return MIPS assembly for a stack push.
     */
    private String pushToStack() {
        StringBuilder pushString = new StringBuilder();

        // Push to stack.
        pushString.append("addi\t$sp,\t$sp,\t-");
        pushString.append(8 * 4 + 8);
        pushString.append('\n');

        for (int i = 8 - 1; i >= 0; i--) {
            pushString.append("sw\t").append("$s").append(i).append(",\t").append(4 * (i + 2)).append("($sp)\n");
        }

        pushString.append("sw\t$fp,\t4($sp)\n");
        pushString.append("sw\t$ra,\t0($sp)\n");

        return pushString.toString();
    }

    /**
     * Code generation method for popping registers $s*, $fp, and $sp to the stack.
     *
     * @return MIPS assembly for a stack pop.
     */
    private String popFromStack() {
        StringBuilder popString = new StringBuilder();

        // Pop from stack.
        for (int i = 8 - 1; i >= 0; i--) {
            popString.append("lw\t").append("$s").append(i).append(",\t").append(4 * (i + 2)).append("($sp)\n");
        }
        popString.append("lw\t$fp,\t4($sp)\n");
        popString.append("lw\t$ra,\t0($sp)\n");
        popString.append("addi\t$sp,\t$sp,\t");
        popString.append((8 * 4) + 8).append("\n");
        popString.append("jr\t$ra\n");

        return popString.toString();
    }
}
