package analysis;

import scanner.TokenType;
import syntaxtree.*;
import symboltable.*;

import java.util.ArrayList;

/** This class, executed after parsing, analyzes the syntax tree for proper semantic structure within the micro-pascal program.
 *
 * @author William Mork
 */
public class SemanticAnalyzer {

    // The root program node.
    private ProgramNode root;

    // Symbol Table of the parser.
    public SymbolTable symbolTable;

    // True if token types across assignments are valid.
    public boolean validAssignments = true;

    // True if variables are properly declared prior to their use cases.
    public boolean validDeclarations = true;

    /**
     * Creates a SemanticAnalyzer and runs semantic analysis on a root program node.
     *
     * @param rootNode Root program node generated by the parser.
     * @param finalSymbolTable Symbol Table generated by the parser.
     */
    public SemanticAnalyzer(ProgramNode rootNode, SymbolTable finalSymbolTable) {
        root = rootNode;
        symbolTable = finalSymbolTable;
        DeclarationsNode rootDeclarations = root.getDeclarations();
        SubProgramDeclarationsNode rootSubprogramDeclarations = root.getSubProgramDeclarations();

        testSemantics(root.getCompoundStatement());

        if (!validAssignments) {
            System.out.println("Compiler Error: Variable types not consistent across assignments");
        }

        if (!validDeclarations) {
            System.out.println("Compiler Error: One or more variables has not been declared before its use case.");
        }

        if (validAssignments && validDeclarations) {
            System.out.println("Program passed semantic analysis");
        } else {
            System.out.println("Program failed semantic analysis");
        }
    }

    /**
     * Tests that variables are declared before their use case and checks for proper token types across assignments and operations.
     * @param rootCompoundStatement Child compound statement node of the root program node.
     */
    public void testSemantics(CompoundStatementNode rootCompoundStatement) {
        for (StatementNode statement : rootCompoundStatement.statements) {
            if (statement instanceof AssignmentStatementNode) {
                TokenType leftVarType = null;
                TokenType expressionType = null;
                AssignmentStatementNode thisAssignmentStatement = ((AssignmentStatementNode) statement);
                leftVarType = thisAssignmentStatement.getLvalue().getType();
                ExpressionNode thisExpression = ((AssignmentStatementNode) statement).getExpression();
                traverseOperation(thisExpression, leftVarType);
            }
        }
    }

    /**
     * Recursively traverses a compound statement for semantic analysis.
     * @param expressionNode A top-level expression node.
     * @param expectedType The token type of the variable which precedes the assignment operator.
     */
    public void traverseOperation(ExpressionNode expressionNode, TokenType expectedType) {
        expectedType = expectedType;

        if (expressionNode instanceof OperationNode) {
            OperationNode thisOperation = ((OperationNode) expressionNode);
            ExpressionNode leftExpression = thisOperation.getLeft();
            traverseOperation(leftExpression, expectedType);
            ExpressionNode rightExpression = thisOperation.getRight();
            traverseOperation(rightExpression, expectedType);
        } else if (expressionNode.getType() != null && expressionNode.getType() != expectedType) {
            validAssignments = false;
        }

        if (expressionNode instanceof ArrayNode) {
            ArrayNode thisArray = ((ArrayNode) expressionNode);
            String arrayName = thisArray.getName();
            if (!symbolTable.isArray(arrayName)) {
                validDeclarations = false;
            }
        } else if (expressionNode instanceof VariableNode) {
            VariableNode thisVariable = ((VariableNode) expressionNode);
            String variableName = thisVariable.getName();
            if (!symbolTable.isVariable(variableName)) {
                validDeclarations = false;
            }
        }
    }
}
